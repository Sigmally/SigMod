! function() {
  var t = {
    258: function(t) {
      ! function(e) {
        t.exports = e;
        var i = "listeners",
          r = {
            on: function(t, e) {
              return o(this, t).push(e), this
            },
            once: function(t, e) {
              var i = this;
              return r.originalListener = e, o(i, t).push(r), i;

              function r() {
                n.call(i, t, r), e.apply(this, arguments)
              }
            },
            off: n,
            emit: function(t, e) {
              var i = this,
                r = o(i, t, !0);
              if (!r) return !1;
              var s = arguments.length;
              if (1 === s) r.forEach(h);
              else if (2 === s) r.forEach(a);
              else {
                var n = Array.prototype.slice.call(arguments, 1);
                r.forEach(c)
              }
              return !!r.length;

              function h(t) {
                t.call(i)
              }

              function a(t) {
                t.call(i, e)
              }

              function c(t) {
                t.apply(i, n)
              }
            }
          };

        function s(t) {
          for (var e in r) t[e] = r[e];
          return t
        }

        function n(t, e) {
          var r, s = this;
          if (arguments.length) {
            if (e) {
              if (r = o(s, t, !0)) {
                if (!(r = r.filter(h)).length) return n.call(s, t);
                s[i][t] = r
              }
            } else if ((r = s[i]) && (delete r[t], !Object.keys(r).length)) return n.call(s)
          } else delete s[i];
          return s;

          function h(t) {
            return t !== e && t.originalListener !== e
          }
        }

        function o(t, e, r) {
          if (!r || t[i]) {
            var s = t[i] || (t[i] = {});
            return s[e] || (s[e] = [])
          }
        }
        s(e.prototype), e.mixin = s
      }((function t() {
        if (!(this instanceof t)) return new t
      }))
    },
    645: function(t, e) {
      e.read = function(t, e, i, r, s) {
        var n, o, h = 8 * s - r - 1,
          a = (1 << h) - 1,
          c = a >> 1,
          u = -7,
          f = i ? s - 1 : 0,
          l = i ? -1 : 1,
          d = t[e + f];
        for (f += l, n = d & (1 << -u) - 1, d >>= -u, u += h; u > 0; n = 256 * n + t[e + f], f += l, u -= 8);
        for (o = n & (1 << -u) - 1, n >>= -u, u += r; u > 0; o = 256 * o + t[e + f], f += l, u -= 8);
        if (0 === n) n = 1 - c;
        else {
          if (n === a) return o ? NaN : 1 / 0 * (d ? -1 : 1);
          o += Math.pow(2, r), n -= c
        }
        return (d ? -1 : 1) * o * Math.pow(2, n - r)
      }, e.write = function(t, e, i, r, s, n) {
        var o, h, a, c = 8 * n - s - 1,
          u = (1 << c) - 1,
          f = u >> 1,
          l = 23 === s ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
          d = r ? 0 : n - 1,
          p = r ? 1 : -1,
          y = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (h = isNaN(e) ? 1 : 0, o = u) : (o = Math.floor(Math.log(e) / Math.LN2), e * (a = Math.pow(2, -o)) < 1 && (o--, a *= 2), (e += o + f >= 1 ? l / a : l * Math.pow(2, 1 - f)) * a >= 2 && (o++, a /= 2), o + f >= u ? (h = 0, o = u) : o + f >= 1 ? (h = (e * a - 1) * Math.pow(2, s), o += f) : (h = e * Math.pow(2, f - 1) * Math.pow(2, s), o = 0)); s >= 8; t[i + d] = 255 & h, d += p, h /= 256, s -= 8);
        for (o = o << s | h, c += s; c > 0; t[i + d] = 255 & o, d += p, o /= 256, c -= 8);
        t[i + d - p] |= 128 * y
      }
    },
    166: function(t, e) {
      ! function(t) {
        var e, i = "undefined",
          r = i !== typeof Buffer && Buffer,
          s = i !== typeof Uint8Array && Uint8Array,
          n = i !== typeof ArrayBuffer && ArrayBuffer,
          o = [0, 0, 0, 0, 0, 0, 0, 0],
          h = Array.isArray || function(t) {
            return !!t && "[object Array]" == Object.prototype.toString.call(t)
          },
          a = 4294967296;

        function c(h, c, x) {
          var b = c ? 0 : 4,
            k = c ? 4 : 0,
            E = c ? 0 : 3,
            A = c ? 1 : 2,
            U = c ? 2 : 1,
            B = c ? 3 : 0,
            M = c ? v : w,
            T = c ? g : m,
            P = I.prototype,
            S = "is" + h,
            C = "_" + S;
          return P.buffer = void 0, P.offset = 0, P[C] = !0, P.toNumber = R, P.toString = function(t) {
            var e = this.buffer,
              i = this.offset,
              r = j(e, i + b),
              s = j(e, i + k),
              n = "",
              o = !x && 2147483648 & r;
            for (o && (r = ~r, s = a - s), t = t || 10; ;) {
              var h = r % t * a + s;
              if (r = Math.floor(r / t), s = Math.floor(h / t), n = (h % t).toString(t) + n, !r && !s) break
            }
            return o && (n = "-" + n), n
          }, P.toJSON = R, P.toArray = u, r && (P.toBuffer = f), s && (P.toArrayBuffer = l), I[S] = function(t) {
            return !(!t || !t[C])
          }, t[h] = I, I;

          function I(t, r, h, c) {
            return this instanceof I ? function(t, r, h, c, u) {
              s && n && (r instanceof n && (r = new s(r)), c instanceof n && (c = new s(c))), r || h || c || e ? (d(r, h) || (u = h, c = r, h = 0, r = new (e || Array)(8)), t.buffer = r, t.offset = h |= 0, i !== typeof c && ("string" == typeof c ? function(t, e, i, r) {
                var s = 0,
                  n = i.length,
                  o = 0,
                  h = 0;
                "-" === i[0] && s++;
                for (var c = s; s < n;) {
                  var u = parseInt(i[s++], r);
                  if (!(u >= 0)) break;
                  h = h * r + u, o = o * r + Math.floor(h / a), h %= a
                }
                c && (o = ~o, h ? h = a - h : o++), D(t, e + b, o), D(t, e + k, h)
              }(r, h, c, u || 10) : d(c, u) ? p(r, h, c, u) : "number" == typeof u ? (D(r, h + b, c), D(r, h + k, u)) : c > 0 ? M(r, h, c) : c < 0 ? T(r, h, c) : p(r, h, o, 0))) : t.buffer = y(o, 0)
            }(this, t, r, h, c) : new I(t, r, h, c)
          }

          function R() {
            var t = this.buffer,
              e = this.offset,
              i = j(t, e + b),
              r = j(t, e + k);
            return x || (i |= 0), i ? i * a + r : r
          }

          function D(t, e, i) {
            t[e + B] = 255 & i, i >>= 8, t[e + U] = 255 & i, i >>= 8, t[e + A] = 255 & i, i >>= 8, t[e + E] = 255 & i
          }

          function j(t, e) {
            return 16777216 * t[e + E] + (t[e + A] << 16) + (t[e + U] << 8) + t[e + B]
          }
        }

        function u(t) {
          var i = this.buffer,
            r = this.offset;
          return e = null, !1 !== t && 0 === r && 8 === i.length && h(i) ? i : y(i, r)
        }

        function f(t) {
          var i = this.buffer,
            s = this.offset;
          if (e = r, !1 !== t && 0 === s && 8 === i.length && Buffer.isBuffer(i)) return i;
          var n = new r(8);
          return p(n, 0, i, s), n
        }

        function l(t) {
          var i = this.buffer,
            r = this.offset,
            o = i.buffer;
          if (e = s, !1 !== t && 0 === r && o instanceof n && 8 === o.byteLength) return o;
          var h = new s(8);
          return p(h, 0, i, r), h.buffer
        }

        function d(t, e) {
          var i = t && t.length;
          return e |= 0, i && e + 8 <= i && "string" != typeof t[e]
        }

        function p(t, e, i, r) {
          e |= 0, r |= 0;
          for (var s = 0; s < 8; s++) t[e++] = 255 & i[r++]
        }

        function y(t, e) {
          return Array.prototype.slice.call(t, e, e + 8)
        }

        function v(t, e, i) {
          for (var r = e + 8; r > e;) t[--r] = 255 & i, i /= 256
        }

        function g(t, e, i) {
          var r = e + 8;
          for (i++; r > e;) t[--r] = 255 & -i ^ 255, i /= 256
        }

        function w(t, e, i) {
          for (var r = e + 8; e < r;) t[e++] = 255 & i, i /= 256
        }

        function m(t, e, i) {
          var r = e + 8;
          for (i++; e < r;) t[e++] = 255 & -i ^ 255, i /= 256
        }
        c("Uint64BE", !0, !0), c("Int64BE", !0, !1), c("Uint64LE", !1, !0), c("Int64LE", !1, !1)
      }("string" != typeof e.nodeName ? e : this || {})
    },
    826: function(t) {
      var e = {}.toString;
      t.exports = Array.isArray || function(t) {
        return "[object Array]" == e.call(t)
      }
    },
    374: function(t, e, i) {
      e.encode = i(764).encode, e.decode = i(299).decode, e.Encoder = i(883).Encoder, e.Decoder = i(441).Decoder, e.createCodec = i(832).createCodec, e.codec = i(766).codec
    },
    679: function(t) {
      function e(t) {
        return t && t.isBuffer && t
      }
      t.exports = e("undefined" != typeof Buffer && Buffer) || e(this.Buffer) || e("undefined" != typeof window && window.Buffer) || this.Buffer
    },
    947: function(t, e) {
      e.copy = function(t, e, i, r) {
        var s;
        i || (i = 0), r || 0 === r || (r = this.length), e || (e = 0);
        var n = r - i;
        if (t === this && i < e && e < r)
          for (s = n - 1; s >= 0; s--) t[s + e] = this[s + i];
        else
          for (s = 0; s < n; s++) t[s + e] = this[s + i];
        return n
      }, e.toString = function(t, e, i) {
        var r = this,
          s = 0 | e;
        i || (i = r.length);
        for (var n = "", o = 0; s < i;)(o = r[s++]) < 128 ? n += String.fromCharCode(o) : (192 == (224 & o) ? o = (31 & o) << 6 | 63 & r[s++] : 224 == (240 & o) ? o = (15 & o) << 12 | (63 & r[s++]) << 6 | 63 & r[s++] : 240 == (248 & o) && (o = (7 & o) << 18 | (63 & r[s++]) << 12 | (63 & r[s++]) << 6 | 63 & r[s++]), o >= 65536 ? (o -= 65536, n += String.fromCharCode(55296 + (o >>> 10), 56320 + (1023 & o))) : n += String.fromCharCode(o));
        return n
      }, e.write = function(t, e) {
        for (var i = this, r = e || (e |= 0), s = t.length, n = 0, o = 0; o < s;)(n = t.charCodeAt(o++)) < 128 ? i[r++] = n : n < 2048 ? (i[r++] = 192 | n >>> 6, i[r++] = 128 | 63 & n) : n < 55296 || n > 57343 ? (i[r++] = 224 | n >>> 12, i[r++] = 128 | n >>> 6 & 63, i[r++] = 128 | 63 & n) : (n = 65536 + (n - 55296 << 10 | t.charCodeAt(o++) - 56320), i[r++] = 240 | n >>> 18, i[r++] = 128 | n >>> 12 & 63, i[r++] = 128 | n >>> 6 & 63, i[r++] = 128 | 63 & n);
        return r - e
      }
    },
    683: function(t, e, i) {
      var r = i(895),
        s = t.exports = n(0);

      function n(t) {
        return new Array(t)
      }
      s.alloc = n, s.concat = r.concat, s.from = function(t) {
        if (!r.isBuffer(t) && r.isView(t)) t = r.Uint8Array.from(t);
        else if (r.isArrayBuffer(t)) t = new Uint8Array(t);
        else {
          if ("string" == typeof t) return r.from.call(s, t);
          if ("number" == typeof t) throw new TypeError('"value" argument must not be a number')
        }
        return Array.prototype.slice.call(t)
      }
    },
    580: function(t, e, i) {
      var r = i(895),
        s = r.global,
        n = t.exports = r.hasBuffer ? o(0) : [];

      function o(t) {
        return new s(t)
      }
      n.alloc = r.hasBuffer && s.alloc || o, n.concat = r.concat, n.from = function(t) {
        if (!r.isBuffer(t) && r.isView(t)) t = r.Uint8Array.from(t);
        else if (r.isArrayBuffer(t)) t = new Uint8Array(t);
        else {
          if ("string" == typeof t) return r.from.call(n, t);
          if ("number" == typeof t) throw new TypeError('"value" argument must not be a number')
        }
        return s.from && 1 !== s.from.length ? s.from(t) : new s(t)
      }
    },
    190: function(t, e, i) {
      var r, s = i(947);
      e.copy = c, e.slice = u, e.toString = function(t, e, i) {
        var r = !h && n.isBuffer(this) ? this.toString : s.toString;
        return r.apply(this, arguments)
      }, e.write = (r = "write", function() {
        return (this[r] || s[r]).apply(this, arguments)
      });
      var n = i(895),
        o = n.global,
        h = n.hasBuffer && "TYPED_ARRAY_SUPPORT" in o,
        a = h && !o.TYPED_ARRAY_SUPPORT;

      function c(t, e, i, r) {
        var o = n.isBuffer(this),
          h = n.isBuffer(t);
        if (o && h) return this.copy(t, e, i, r);
        if (a || o || h || !n.isView(this) || !n.isView(t)) return s.copy.call(this, t, e, i, r);
        var c = i || null != r ? u.call(this, i, r) : this;
        return t.set(c, e), c.length
      }

      function u(t, e) {
        var i = this.slice || !a && this.subarray;
        if (i) return i.call(this, t, e);
        var r = n.alloc.call(this, e - t);
        return c.call(this, r, 0, t, e), r
      }
    },
    37: function(t, e, i) {
      var r = i(895),
        s = t.exports = r.hasArrayBuffer ? n(0) : [];

      function n(t) {
        return new Uint8Array(t)
      }
      s.alloc = n, s.concat = r.concat, s.from = function(t) {
        if (r.isView(t)) {
          var e = t.byteOffset,
            i = t.byteLength;
          (t = t.buffer).byteLength !== i && (t.slice ? t = t.slice(e, e + i) : (t = new Uint8Array(t)).byteLength !== i && (t = Array.prototype.slice.call(t, e, e + i)))
        } else {
          if ("string" == typeof t) return r.from.call(s, t);
          if ("number" == typeof t) throw new TypeError('"value" argument must not be a number')
        }
        return new Uint8Array(t)
      }
    },
    895: function(t, e, i) {
      var r = e.global = i(679),
        s = e.hasBuffer = r && !!r.isBuffer,
        n = e.hasArrayBuffer = "undefined" != typeof ArrayBuffer,
        o = e.isArray = i(826);
      e.isArrayBuffer = n ? function(t) {
        return t instanceof ArrayBuffer || p(t)
      } : g;
      var h = e.isBuffer = s ? r.isBuffer : g,
        a = e.isView = n ? ArrayBuffer.isView || w("ArrayBuffer", "buffer") : g;
      e.alloc = d, e.concat = function(t, i) {
        i || (i = 0, Array.prototype.forEach.call(t, (function(t) {
          i += t.length
        })));
        var r = this !== e && this || t[0],
          s = d.call(r, i),
          n = 0;
        return Array.prototype.forEach.call(t, (function(t) {
          n += l.copy.call(t, s, n)
        })), s
      }, e.from = function(t) {
        return "string" == typeof t ? y.call(this, t) : v(this).from(t)
      };
      var c = e.Array = i(683),
        u = e.Buffer = i(580),
        f = e.Uint8Array = i(37),
        l = e.prototype = i(190);

      function d(t) {
        return v(this).alloc(t)
      }
      var p = w("ArrayBuffer");

      function y(t) {
        var e = 3 * t.length,
          i = d.call(this, e),
          r = l.write.call(i, t);
        return e !== r && (i = l.slice.call(i, 0, r)), i
      }

      function v(t) {
        return h(t) ? u : a(t) ? f : o(t) ? c : s ? u : n ? f : c
      }

      function g() {
        return !1
      }

      function w(t, e) {
        return t = "[object " + t + "]",
          function(i) {
            return null != i && {}.toString.call(e ? i[e] : i) === t
          }
      }
    },
    877: function(t, e, i) {
      var r = i(826);
      e.createCodec = h, e.install = function(t) {
        for (var e in t) n.prototype[e] = o(n.prototype[e], t[e])
      }, e.filter = function(t) {
        return r(t) ? function(t) {
          return t = t.slice(),
            function(i) {
              return t.reduce(e, i)
            };

          function e(t, e) {
            return e(t)
          }
        }(t) : t
      };
      var s = i(895);

      function n(t) {
        if (!(this instanceof n)) return new n(t);
        this.options = t, this.init()
      }

      function o(t, e) {
        return t && e ? function() {
          return t.apply(this, arguments), e.apply(this, arguments)
        } : t || e
      }

      function h(t) {
        return new n(t)
      }
      n.prototype.init = function() {
        var t = this.options;
        return t && t.uint8array && (this.bufferish = s.Uint8Array), this
      }, e.preset = h({
        preset: !0
      })
    },
    766: function(t, e, i) {
      i(350), i(312), e.codec = {
        preset: i(877).preset
      }
    },
    170: function(t, e, i) {
      e.T = s;
      var r = i(350).preset;

      function s(t) {
        if (!(this instanceof s)) return new s(t);
        if (t && (this.options = t, t.codec)) {
          var e = this.codec = t.codec;
          e.bufferish && (this.bufferish = e.bufferish)
        }
      }
      i(822).k.mixin(s.prototype), s.prototype.codec = r, s.prototype.fetch = function() {
        return this.codec.decode(this)
      }
    },
    299: function(t, e, i) {
      e.decode = function(t, e) {
        var i = new r(e);
        return i.write(t), i.read()
      };
      var r = i(170).T
    },
    441: function(t, e, i) {
      e.Decoder = n;
      var r = i(258),
        s = i(170).T;

      function n(t) {
        if (!(this instanceof n)) return new n(t);
        s.call(this, t)
      }
      n.prototype = new s, r.mixin(n.prototype), n.prototype.decode = function(t) {
        arguments.length && this.write(t), this.flush()
      }, n.prototype.push = function(t) {
        this.emit("data", t)
      }, n.prototype.end = function(t) {
        this.decode(t), this.emit("end")
      }
    },
    517: function(t, e, i) {
      e.F = s;
      var r = i(312).preset;

      function s(t) {
        if (!(this instanceof s)) return new s(t);
        if (t && (this.options = t, t.codec)) {
          var e = this.codec = t.codec;
          e.bufferish && (this.bufferish = e.bufferish)
        }
      }
      i(822).I.mixin(s.prototype), s.prototype.codec = r, s.prototype.write = function(t) {
        this.codec.encode(this, t)
      }
    },
    764: function(t, e, i) {
      e.encode = function(t, e) {
        var i = new r(e);
        return i.write(t), i.read()
      };
      var r = i(517).F
    },
    883: function(t, e, i) {
      e.Encoder = n;
      var r = i(258),
        s = i(517).F;

      function n(t) {
        if (!(this instanceof n)) return new n(t);
        s.call(this, t)
      }
      n.prototype = new s, r.mixin(n.prototype), n.prototype.encode = function(t) {
        this.write(t), this.emit("data", this.read())
      }, n.prototype.end = function(t) {
        arguments.length && this.encode(t), this.flush(), this.emit("end")
      }
    },
    83: function(t, e, i) {
      e.S = function t(e, i) {
        if (!(this instanceof t)) return new t(e, i);
        this.buffer = r.from(e), this.type = i
      };
      var r = i(895)
    },
    431: function(t, e, i) {
      e.setExtPackers = function(t) {
        t.addExtPacker(14, Error, [f, a]), t.addExtPacker(1, EvalError, [f, a]), t.addExtPacker(2, RangeError, [f, a]), t.addExtPacker(3, ReferenceError, [f, a]), t.addExtPacker(4, SyntaxError, [f, a]), t.addExtPacker(5, TypeError, [f, a]), t.addExtPacker(6, URIError, [f, a]), t.addExtPacker(10, RegExp, [u, a]), t.addExtPacker(11, Boolean, [c, a]), t.addExtPacker(12, String, [c, a]), t.addExtPacker(13, Date, [Number, a]), t.addExtPacker(15, Number, [c, a]), "undefined" != typeof Uint8Array && (t.addExtPacker(17, Int8Array, o), t.addExtPacker(18, Uint8Array, o), t.addExtPacker(19, Int16Array, o), t.addExtPacker(20, Uint16Array, o), t.addExtPacker(21, Int32Array, o), t.addExtPacker(22, Uint32Array, o), t.addExtPacker(23, Float32Array, o), "undefined" != typeof Float64Array && t.addExtPacker(24, Float64Array, o), "undefined" != typeof Uint8ClampedArray && t.addExtPacker(25, Uint8ClampedArray, o), t.addExtPacker(26, ArrayBuffer, o), t.addExtPacker(29, DataView, o)), s.hasBuffer && t.addExtPacker(27, n, s.from)
      };
      var r, s = i(895),
        n = s.global,
        o = s.Uint8Array.from,
        h = {
          name: 1,
          message: 1,
          stack: 1,
          columnNumber: 1,
          fileName: 1,
          lineNumber: 1
        };

      function a(t) {
        return r || (r = i(764).encode), r(t)
      }

      function c(t) {
        return t.valueOf()
      }

      function u(t) {
        (t = RegExp.prototype.toString.call(t).split("/")).shift();
        var e = [t.pop()];
        return e.unshift(t.join("/")), e
      }

      function f(t) {
        var e = {};
        for (var i in h) e[i] = t[i];
        return e
      }
    },
    600: function(t, e, i) {
      e.setExtUnpackers = function(t) {
        t.addExtUnpacker(14, [h, c(Error)]), t.addExtUnpacker(1, [h, c(EvalError)]), t.addExtUnpacker(2, [h, c(RangeError)]), t.addExtUnpacker(3, [h, c(ReferenceError)]), t.addExtUnpacker(4, [h, c(SyntaxError)]), t.addExtUnpacker(5, [h, c(TypeError)]), t.addExtUnpacker(6, [h, c(URIError)]), t.addExtUnpacker(10, [h, a]), t.addExtUnpacker(11, [h, u(Boolean)]), t.addExtUnpacker(12, [h, u(String)]), t.addExtUnpacker(13, [h, u(Date)]), t.addExtUnpacker(15, [h, u(Number)]), "undefined" != typeof Uint8Array && (t.addExtUnpacker(17, u(Int8Array)), t.addExtUnpacker(18, u(Uint8Array)), t.addExtUnpacker(19, [f, u(Int16Array)]), t.addExtUnpacker(20, [f, u(Uint16Array)]), t.addExtUnpacker(21, [f, u(Int32Array)]), t.addExtUnpacker(22, [f, u(Uint32Array)]), t.addExtUnpacker(23, [f, u(Float32Array)]), "undefined" != typeof Float64Array && t.addExtUnpacker(24, [f, u(Float64Array)]), "undefined" != typeof Uint8ClampedArray && t.addExtUnpacker(25, u(Uint8ClampedArray)), t.addExtUnpacker(26, f), t.addExtUnpacker(29, [f, u(DataView)])), s.hasBuffer && t.addExtUnpacker(27, u(n))
      };
      var r, s = i(895),
        n = s.global,
        o = {
          name: 1,
          message: 1,
          stack: 1,
          columnNumber: 1,
          fileName: 1,
          lineNumber: 1
        };

      function h(t) {
        return r || (r = i(299).decode), r(t)
      }

      function a(t) {
        return RegExp.apply(null, t)
      }

      function c(t) {
        return function(e) {
          var i = new t;
          for (var r in o) i[r] = e[r];
          return i
        }
      }

      function u(t) {
        return function(e) {
          return new t(e)
        }
      }

      function f(t) {
        return new Uint8Array(t).buffer
      }
    },
    832: function(t, e, i) {
      i(350), i(312), e.createCodec = i(877).createCodec
    },
    822: function(t, e, i) {
      e.k = n, e.I = o;
      var r = i(895),
        s = "BUFFER_SHORTAGE";

      function n() {
        if (!(this instanceof n)) return new n
      }

      function o() {
        if (!(this instanceof o)) return new o
      }

      function h() {
        return this.buffers && this.buffers.length ? (this.flush(), this.pull()) : this.fetch()
      }

      function a(t) {
        (this.buffers || (this.buffers = [])).push(t)
      }

      function c(t) {
        return function(e) {
          for (var i in t) e[i] = t[i];
          return e
        }
      }
      n.mixin = c({
        bufferish: r,
        write: function(t) {
          var e = this.offset ? r.prototype.slice.call(this.buffer, this.offset) : this.buffer;
          this.buffer = e ? t ? this.bufferish.concat([e, t]) : e : t, this.offset = 0
        },
        fetch: function() {
          throw new Error("method not implemented: fetch()")
        },
        flush: function() {
          for (; this.offset < this.buffer.length;) {
            var t, e = this.offset;
            try {
              t = this.fetch()
            } catch (t) {
              if (t && t.message != s) throw t;
              this.offset = e;
              break
            }
            this.push(t)
          }
        },
        push: a,
        pull: function() {
          return (this.buffers || (this.buffers = [])).shift()
        },
        read: h,
        reserve: function(t) {
          var e = this.offset,
            i = e + t;
          if (i > this.buffer.length) throw new Error(s);
          return this.offset = i, e
        },
        offset: 0
      }), n.mixin(n.prototype), o.mixin = c({
        bufferish: r,
        write: function() {
          throw new Error("method not implemented: write()")
        },
        fetch: function() {
          var t = this.start;
          if (t < this.offset) {
            var e = this.start = this.offset;
            return r.prototype.slice.call(this.buffer, t, e)
          }
        },
        flush: function() {
          for (; this.start < this.offset;) {
            var t = this.fetch();
            t && this.push(t)
          }
        },
        push: a,
        pull: function() {
          var t = this.buffers || (this.buffers = []),
            e = t.length > 1 ? this.bufferish.concat(t) : t[0];
          return t.length = 0, e
        },
        read: h,
        reserve: function(t) {
          var e = 0 | t;
          if (this.buffer) {
            var i = this.buffer.length,
              r = 0 | this.offset,
              s = r + e;
            if (s < i) return this.offset = s, r;
            this.flush(), t = Math.max(t, Math.min(2 * i, this.maxBufferSize))
          }
          return t = Math.max(t, this.minBufferSize), this.buffer = this.bufferish.alloc(t), this.start = 0, this.offset = e, 0
        },
        send: function(t) {
          var e = t.length;
          if (e > this.minBufferSize) this.flush(), this.push(t);
          else {
            var i = this.reserve(e);
            r.prototype.copy.call(t, this.buffer, i)
          }
        },
        maxBufferSize: 65536,
        minBufferSize: 2048,
        offset: 0,
        start: 0
      }), o.mixin(o.prototype)
    },
    350: function(t, e, i) {
      var r = i(83).S,
        s = i(600),
        n = i(76).readUint8,
        o = i(738),
        h = i(877);

      function a() {
        var t = this.options;
        return this.decode = function(t) {
          var e = o.getReadToken(t);
          return function(t) {
            var i = n(t),
              r = e[i];
            if (!r) throw new Error("Invalid type: " + (i ? "0x" + i.toString(16) : i));
            return r(t)
          }
        }(t), t && t.preset && s.setExtUnpackers(this), this
      }
      h.install({
        addExtUnpacker: function(t, e) {
          (this.extUnpackers || (this.extUnpackers = []))[t] = h.filter(e)
        },
        getExtUnpacker: function(t) {
          return (this.extUnpackers || (this.extUnpackers = []))[t] || function(e) {
            return new r(e, t)
          }
        },
        init: a
      }), e.preset = a.call(h.preset)
    },
    76: function(t, e, i) {
      var r = i(645),
        s = i(166),
        n = s.Uint64BE,
        o = s.Int64BE;
      e.getReadFormat = function(t) {
        var e = h.hasArrayBuffer && t && t.binarraybuffer,
          i = t && t.int64;
        return {
          map: c && t && t.usemap ? f : u,
          array: l,
          str: d,
          bin: e ? y : p,
          ext: v,
          uint8: g,
          uint16: m,
          uint32: b,
          uint64: E(8, i ? B : A),
          int8: w,
          int16: x,
          int32: k,
          int64: E(8, i ? M : U),
          float32: E(4, T),
          float64: E(8, P)
        }
      }, e.readUint8 = g;
      var h = i(895),
        a = i(190),
        c = "undefined" != typeof Map;

      function u(t, e) {
        var i, r = {},
          s = new Array(e),
          n = new Array(e),
          o = t.codec.decode;
        for (i = 0; i < e; i++) s[i] = o(t), n[i] = o(t);
        for (i = 0; i < e; i++) r[s[i]] = n[i];
        return r
      }

      function f(t, e) {
        var i, r = new Map,
          s = new Array(e),
          n = new Array(e),
          o = t.codec.decode;
        for (i = 0; i < e; i++) s[i] = o(t), n[i] = o(t);
        for (i = 0; i < e; i++) r.set(s[i], n[i]);
        return r
      }

      function l(t, e) {
        for (var i = new Array(e), r = t.codec.decode, s = 0; s < e; s++) i[s] = r(t);
        return i
      }

      function d(t, e) {
        var i = t.reserve(e),
          r = i + e;
        return a.toString.call(t.buffer, "utf-8", i, r)
      }

      function p(t, e) {
        var i = t.reserve(e),
          r = i + e,
          s = a.slice.call(t.buffer, i, r);
        return h.from(s)
      }

      function y(t, e) {
        var i = t.reserve(e),
          r = i + e,
          s = a.slice.call(t.buffer, i, r);
        return h.Uint8Array.from(s).buffer
      }

      function v(t, e) {
        var i = t.reserve(e + 1),
          r = t.buffer[i++],
          s = i + e,
          n = t.codec.getExtUnpacker(r);
        if (!n) throw new Error("Invalid ext type: " + (r ? "0x" + r.toString(16) : r));
        return n(a.slice.call(t.buffer, i, s))
      }

      function g(t) {
        var e = t.reserve(1);
        return t.buffer[e]
      }

      function w(t) {
        var e = t.reserve(1),
          i = t.buffer[e];
        return 128 & i ? i - 256 : i
      }

      function m(t) {
        var e = t.reserve(2),
          i = t.buffer;
        return i[e++] << 8 | i[e]
      }

      function x(t) {
        var e = t.reserve(2),
          i = t.buffer,
          r = i[e++] << 8 | i[e];
        return 32768 & r ? r - 65536 : r
      }

      function b(t) {
        var e = t.reserve(4),
          i = t.buffer;
        return 16777216 * i[e++] + (i[e++] << 16) + (i[e++] << 8) + i[e]
      }

      function k(t) {
        var e = t.reserve(4),
          i = t.buffer;
        return i[e++] << 24 | i[e++] << 16 | i[e++] << 8 | i[e]
      }

      function E(t, e) {
        return function(i) {
          var r = i.reserve(t);
          return e.call(i.buffer, r, !0)
        }
      }

      function A(t) {
        return new n(this, t).toNumber()
      }

      function U(t) {
        return new o(this, t).toNumber()
      }

      function B(t) {
        return new n(this, t)
      }

      function M(t) {
        return new o(this, t)
      }

      function T(t) {
        return r.read(this, t, !1, 23, 4)
      }

      function P(t) {
        return r.read(this, t, !1, 52, 8)
      }
    },
    738: function(t, e, i) {
      var r = i(76);

      function s(t) {
        var e, i = new Array(256);
        for (e = 0; e <= 127; e++) i[e] = n(e);
        for (e = 128; e <= 143; e++) i[e] = h(e - 128, t.map);
        for (e = 144; e <= 159; e++) i[e] = h(e - 144, t.array);
        for (e = 160; e <= 191; e++) i[e] = h(e - 160, t.str);
        for (i[192] = n(null), i[193] = null, i[194] = n(!1), i[195] = n(!0), i[196] = o(t.uint8, t.bin), i[197] = o(t.uint16, t.bin), i[198] = o(t.uint32, t.bin), i[199] = o(t.uint8, t.ext), i[200] = o(t.uint16, t.ext), i[201] = o(t.uint32, t.ext), i[202] = t.float32, i[203] = t.float64, i[204] = t.uint8, i[205] = t.uint16, i[206] = t.uint32, i[207] = t.uint64, i[208] = t.int8, i[209] = t.int16, i[210] = t.int32, i[211] = t.int64, i[212] = h(1, t.ext), i[213] = h(2, t.ext), i[214] = h(4, t.ext), i[215] = h(8, t.ext), i[216] = h(16, t.ext), i[217] = o(t.uint8, t.str), i[218] = o(t.uint16, t.str), i[219] = o(t.uint32, t.str), i[220] = o(t.uint16, t.array), i[221] = o(t.uint32, t.array), i[222] = o(t.uint16, t.map), i[223] = o(t.uint32, t.map), e = 224; e <= 255; e++) i[e] = n(e - 256);
        return i
      }

      function n(t) {
        return function() {
          return t
        }
      }

      function o(t, e) {
        return function(i) {
          var r = t(i);
          return e(i, r)
        }
      }

      function h(t, e) {
        return function(i) {
          return e(i, t)
        }
      }
      e.getReadToken = function(t) {
        var e = r.getReadFormat(t);
        return t && t.useraw ? function(t) {
          var e, i = s(t).slice();
          for (i[217] = i[196], i[218] = i[197], i[219] = i[198], e = 160; e <= 191; e++) i[e] = h(e - 160, t.bin);
          return i
        }(e) : s(e)
      }
    },
    312: function(t, e, i) {
      var r = i(83).S,
        s = i(431),
        n = i(943),
        o = i(877);

      function h() {
        var t = this.options;
        return this.encode = function(t) {
          var e = n.getWriteType(t);
          return function(t, i) {
            var r = e[typeof i];
            if (!r) throw new Error('Unsupported type "' + typeof i + '": ' + i);
            r(t, i)
          }
        }(t), t && t.preset && s.setExtPackers(this), this
      }
      o.install({
        addExtPacker: function(t, e, i) {
          i = o.filter(i);
          var s = e.name;

          function n(e) {
            return i && (e = i(e)), new r(e, t)
          }
          s && "Object" !== s ? (this.extPackers || (this.extPackers = {}))[s] = n : (this.extEncoderList || (this.extEncoderList = [])).unshift([e, n])
        },
        getExtPacker: function(t) {
          var e = this.extPackers || (this.extPackers = {}),
            i = t.constructor,
            r = i && i.name && e[i.name];
          if (r) return r;
          for (var s = this.extEncoderList || (this.extEncoderList = []), n = s.length, o = 0; o < n; o++) {
            var h = s[o];
            if (i === h[0]) return h[1]
          }
        },
        init: h
      }), e.preset = h.call(o.preset)
    },
    598: function(t, e, i) {
      var r = i(645),
        s = i(166),
        n = s.Uint64BE,
        o = s.Int64BE,
        h = i(370).w,
        a = i(895),
        c = a.global,
        u = a.hasBuffer && "TYPED_ARRAY_SUPPORT" in c && !c.TYPED_ARRAY_SUPPORT,
        f = a.hasBuffer && c.prototype || {};

      function l() {
        var t = h.slice();
        return t[196] = d(196), t[197] = p(197), t[198] = y(198), t[199] = d(199), t[200] = p(200), t[201] = y(201), t[202] = v(202, 4, f.writeFloatBE || m, !0), t[203] = v(203, 8, f.writeDoubleBE || x, !0), t[204] = d(204), t[205] = p(205), t[206] = y(206), t[207] = v(207, 8, g), t[208] = d(208), t[209] = p(209), t[210] = y(210), t[211] = v(211, 8, w), t[217] = d(217), t[218] = p(218), t[219] = y(219), t[220] = p(220), t[221] = y(221), t[222] = p(222), t[223] = y(223), t
      }

      function d(t) {
        return function(e, i) {
          var r = e.reserve(2),
            s = e.buffer;
          s[r++] = t, s[r] = i
        }
      }

      function p(t) {
        return function(e, i) {
          var r = e.reserve(3),
            s = e.buffer;
          s[r++] = t, s[r++] = i >>> 8, s[r] = i
        }
      }

      function y(t) {
        return function(e, i) {
          var r = e.reserve(5),
            s = e.buffer;
          s[r++] = t, s[r++] = i >>> 24, s[r++] = i >>> 16, s[r++] = i >>> 8, s[r] = i
        }
      }

      function v(t, e, i, r) {
        return function(s, n) {
          var o = s.reserve(e + 1);
          s.buffer[o++] = t, i.call(s.buffer, n, o, r)
        }
      }

      function g(t, e) {
        new n(this, e, t)
      }

      function w(t, e) {
        new o(this, e, t)
      }

      function m(t, e) {
        r.write(this, t, e, !1, 23, 4)
      }

      function x(t, e) {
        r.write(this, t, e, !1, 52, 8)
      }
      e.getWriteToken = function(t) {
        return t && t.uint8array ? ((e = l())[202] = v(202, 4, m), e[203] = v(203, 8, x), e) : u || a.hasBuffer && t && t.safe ? function() {
          var t = h.slice();
          return t[196] = v(196, 1, c.prototype.writeUInt8), t[197] = v(197, 2, c.prototype.writeUInt16BE), t[198] = v(198, 4, c.prototype.writeUInt32BE), t[199] = v(199, 1, c.prototype.writeUInt8), t[200] = v(200, 2, c.prototype.writeUInt16BE), t[201] = v(201, 4, c.prototype.writeUInt32BE), t[202] = v(202, 4, c.prototype.writeFloatBE), t[203] = v(203, 8, c.prototype.writeDoubleBE), t[204] = v(204, 1, c.prototype.writeUInt8), t[205] = v(205, 2, c.prototype.writeUInt16BE), t[206] = v(206, 4, c.prototype.writeUInt32BE), t[207] = v(207, 8, g), t[208] = v(208, 1, c.prototype.writeInt8), t[209] = v(209, 2, c.prototype.writeInt16BE), t[210] = v(210, 4, c.prototype.writeInt32BE), t[211] = v(211, 8, w), t[217] = v(217, 1, c.prototype.writeUInt8), t[218] = v(218, 2, c.prototype.writeUInt16BE), t[219] = v(219, 4, c.prototype.writeUInt32BE), t[220] = v(220, 2, c.prototype.writeUInt16BE), t[221] = v(221, 4, c.prototype.writeUInt32BE), t[222] = v(222, 2, c.prototype.writeUInt16BE), t[223] = v(223, 4, c.prototype.writeUInt32BE), t
        }() : l();
        var e
      }
    },
    943: function(t, e, i) {
      var r = i(826),
        s = i(166),
        n = s.Uint64BE,
        o = s.Int64BE,
        h = i(895),
        a = i(190),
        c = i(598),
        u = i(370).w,
        f = i(83).S,
        l = "undefined" != typeof Uint8Array,
        d = "undefined" != typeof Map,
        p = [];
      p[1] = 212, p[2] = 213, p[4] = 214, p[8] = 215, p[16] = 216, e.getWriteType = function(t) {
        var e, i = c.getWriteToken(t),
          s = t && t.useraw,
          y = l && t && t.binarraybuffer,
          v = y ? h.isArrayBuffer : h.isBuffer,
          g = y ? function(t, e) {
            b(t, new Uint8Array(e))
          } : b,
          w = d && t && t.usemap ? function(t, e) {
            if (!(e instanceof Map)) return k(t, e);
            var r = e.size;
            i[r < 16 ? 128 + r : r <= 65535 ? 222 : 223](t, r);
            var s = t.codec.encode;
            e.forEach((function(e, i, r) {
              s(t, i), s(t, e)
            }))
          } : k;
        return {
          boolean: function(t, e) {
            i[e ? 195 : 194](t, e)
          },
          function: x,
          number: function(t, e) {
            var r = 0 | e;
            e === r ? i[-32 <= r && r <= 127 ? 255 & r : 0 <= r ? r <= 255 ? 204 : r <= 65535 ? 205 : 206 : -128 <= r ? 208 : -32768 <= r ? 209 : 210](t, r) : i[203](t, e)
          },
          object: s ? function(t, e) {
            if (v(e)) return function(t, e) {
              var r = e.length;
              i[r < 32 ? 160 + r : r <= 65535 ? 218 : 219](t, r), t.send(e)
            }(t, e);
            m(t, e)
          } : m,
          string: (e = s ? function(t) {
            return t < 32 ? 1 : t <= 65535 ? 3 : 5
          } : function(t) {
            return t < 32 ? 1 : t <= 255 ? 2 : t <= 65535 ? 3 : 5
          }, function(t, r) {
            var s = r.length,
              n = 5 + 3 * s;
            t.offset = t.reserve(n);
            var o = t.buffer,
              h = e(s),
              c = t.offset + h;
            s = a.write.call(o, r, c);
            var u = e(s);
            if (h !== u) {
              var f = c + u - h,
                l = c + s;
              a.copy.call(o, o, f, c, l)
            }
            i[1 === u ? 160 + s : u <= 3 ? 215 + u : 219](t, s), t.offset += s
          }),
          symbol: x,
          undefined: x
        };

        function m(t, e) {
          if (null === e) return x(t, e);
          if (v(e)) return g(t, e);
          if (r(e)) return function(t, e) {
            var r = e.length;
            i[r < 16 ? 144 + r : r <= 65535 ? 220 : 221](t, r);
            for (var s = t.codec.encode, n = 0; n < r; n++) s(t, e[n])
          }(t, e);
          if (n.isUint64BE(e)) return function(t, e) {
            i[207](t, e.toArray())
          }(t, e);
          if (o.isInt64BE(e)) return function(t, e) {
            i[211](t, e.toArray())
          }(t, e);
          var s = t.codec.getExtPacker(e);
          if (s && (e = s(e)), e instanceof f) return function(t, e) {
            var r = e.buffer,
              s = r.length,
              n = p[s] || (s < 255 ? 199 : s <= 65535 ? 200 : 201);
            i[n](t, s), u[e.type](t), t.send(r)
          }(t, e);
          w(t, e)
        }

        function x(t, e) {
          i[192](t, e)
        }

        function b(t, e) {
          var r = e.length;
          i[r < 255 ? 196 : r <= 65535 ? 197 : 198](t, r), t.send(e)
        }

        function k(t, e) {
          var r = Object.keys(e),
            s = r.length;
          i[s < 16 ? 128 + s : s <= 65535 ? 222 : 223](t, s);
          var n = t.codec.encode;
          r.forEach((function(i) {
            n(t, i), n(t, e[i])
          }))
        }
      }
    },
    370: function(t, e) {
      for (var i = e.w = new Array(256), r = 0; r <= 255; r++) i[r] = s(r);

      function s(t) {
        return function(e) {
          var i = e.reserve(1);
          e.buffer[i] = t
        }
      }
    }
  },
    e = {};

  function i(r) {
    var s = e[r];
    if (void 0 !== s) return s.exports;
    var n = e[r] = {
      exports: {}
    };
    return t[r].call(n.exports, n, n.exports, i), n.exports
  } ! function() {
    "use strict";
    var t = class {
      constructor(t) {
        this.source = t.getContext("2d"), this.x = 0, this.y = 0, this.active = !1, this.save = !1
      }
      getTextMetrics(t) {
        return this.source.measureText(t)
      }
      getTextWidth(t) {
        return this.getTextMetrics(t).width
      }
      getTextHeight(t) {
        const e = this.getTextMetrics(t);
        return e.actualBoundingBoxAscent + e.actualBoundingBoxDescent
      }
      clear(t = this.source.canvas.width, e = this.source.canvas.height) {
        return this.source.clearRect(0, 0, t, e), this
      }
      background(t) {
        const {
          width: e,
          height: i
        } = this.source.canvas;
        return this.begin(0, 0).setFillColor(t).rect(e, i).end(), this
      }
      setScale(t, e) {
        void 0 === e && (e = t), this.source.scale(t, e)
      }
      init(t = 0, e = 0, i) {
        this.x = t, this.y = e, this.active = !0, this.save = i, this.save && this.source.save()
      }
      begin(t = 0, e = 0, i = !0) {
        return this.init(t, e, i), this
      }
      start(t = 0, e = 0, i = !0) {
        return this.init(t, e, i), this
      }
      loadedImage(t, e, i) {
        if (!(t instanceof Image)) throw new Error(`${t} is not a photo`);
        try {
          this.source.drawImage(t, this.x, this.y, e, i)
        } catch { }
        return this
      }
      image(t, e, i) {
        try {
          const r = new Image;
          r.src = t, this.source.drawImage(r, this.x, this.y, e, i)
        } catch { }
        return this
      }
      rect(t, e, i = "fill") {
        return i.match(/fill|stroke/) ? (this.source[`${i}Rect`](this.x, this.y, t, e), this) : this
      }
      roundRect(t, e, i, r = "fill") {
        return t < 2 * i && (i = t / 2), e < 2 * i && (i = e / 2), i < 0 && (i = 0), this.source.beginPath(), this.source.moveTo(this.x + i, this.y), this.source.arcTo(this.x + t, this.y, this.x + t, this.y + e, i), this.source.arcTo(this.x + t, this.y + e, this.x, this.y + e, i), this.source.arcTo(this.x, this.y + e, this.x, this.y, i), this.source.arcTo(this.x, this.y, this.x + t, this.y, i), this.source.closePath(), r.match(/fill|stroke/) ? (this.source[r](), this) : this
      }
      circle(t, e = "fill") {
        return this.source.beginPath(), this.source.arc(this.x, this.y, t, 0, 2 * Math.PI), this.source.closePath(), e.match(/fill|stroke/) ? (this.source[e](), this) : this
      }
      polygon(t, e = "fill") {
        if (t.length) {
          this.source.moveTo(t[0][0], t[0][1]);
          for (let e = 0; e < t.length; e++) this.source.lineTo(t[e][0], t[e][1]);
          return e.match(/fill|stroke/) ? (this.source[e](), this) : this
        }
      }
      line(t, e, i = "stroke") {
        return this.source.beginPath(), this.source.moveTo(this.x, this.y), this.source.lineTo(t, e), this.source.closePath(), i.match(/fill|stroke/) && this.source[i](), this
      }
      text(t, e = "fill") {
        return e.match(/fill|stroke/) ? (this.source[`${e}Text`](t, this.x, this.y), this) : this
      }
      setFont(t) {
        return this.source.font = t, this
      }
      setRotate(t, e, i) {
        return this.source.translate(e, i), this.source.rotate(t), this
      }
      setTranslate(t, e) {
        return this.source.translate(t, e), this
      }
      setTransform(t) {
        return this.source.setTransform.apply(this.source, arguments), this
      }
      setLineCap(t) {
        return this.source.lineCap = t, this
      }
      setLineJoin(t) {
        return this.source.lineJoin = t, this
      }
      setBaseLine(t) {
        return this.source.textBaseLine = t, this
      }
      setProperty(t, e) {
        return this.source[t] = e, this
      }
      executeMethod(t, e) {
        return this.source[t](...e), this
      }
      setFilter(t) {
        return this.source.filter = t, this
      }
      setAlign(t) {
        return this.source.textAlign = t, this
      }
      setAlpha(t) {
        return this.source.globalAlpha = t, this
      }
      setColors(t = "#1a1a1a", e) {
        return this.source.fillStyle = t, e && (this.source.strokeStyle = e), this
      }
      setFillColor(t) {
        return this.source.fillStyle = t, this
      }
      setStrokeColor(t) {
        return this.source.strokeStyle = t, this
      }
      setLineWidth(t) {
        return this.source.lineWidth = t, this
      }
      doFill() {
        return this.source.fill(), this
      }
      doStroke() {
        return this.source.stroke(), this
      }
      stop() {
        this.reset()
      }
      end() {
        this.reset()
      }
      reset() {
        this.save && this.source.restore(), this.x = 0, this.y = 0, this.width = 0, this.height = 0, this.active = !1, this.save = !1
      }
    },
      e = class {
        constructor() {
          this.rendering = !1, this.reverseRender = !1, this.queue = {
            priority: [],
            default: []
          }, this.delta = {
            current: 0,
            nowUpdate: null,
            lastUpdate: Date.now()
          }, this.started = !1
        }
        setReverseRender(t) {
          this.reverseRender = Boolean(t)
        }
        add(t, e = !1) {
          e = e ? "priority" : "default", this.queue[e].push({
            _function: t,
            priority: e
          })
        }
        update() {
          if (this.rendering) {
            if (this.delta.nowUpdate = Date.now(), this.delta.current = this.delta.nowUpdate - this.delta.lastUpdate, this.delta.lastUpdate = this.delta.nowUpdate, this.reverseRender) {
              let t = this.queue.priority.length;
              for (; t--;) this.queue.priority[t]._function();
              for (t = this.queue.default.length; t--;) this.queue.default[t]._function()
            } else {
              for (let t = 0; t < this.queue.priority.length; t++) this.queue.priority[t]._function();
              for (let t = 0; t < this.queue.default.length; t++) this.queue.default[t]._function()
            }
            requestAnimationFrame(this.update.bind(this))
          }
        }
        toggle() {
          this.rendering = !this.rendering
        }
        start(t = 0) {
          this.rendering = !0, this.started || requestAnimationFrame(this.update.bind(this), t)
        }
        stop() {
          this.rendering = !1
        }
      },
      r = class {
        constructor(t) {
          this.element = t
        }
        get(t) {
          return this.element.style[t]
        }
        set(t) {
          if (Array.isArray(t) || "object" != typeof t) arguments.length > 2 || (this.element.style[arguments[0]] = arguments[1]);
          else
            for (const e in t) this.element.style[e] = t[e]
        }
        reset(t) {
          this.element.style[t] = "none"
        }
      },
      s = class {
        constructor(t) {
          this.element = t, this.events = {}
        }
        has(t) {
          const e = Object.keys(this.events);
          return Boolean(e.filter((e => e === t)).length)
        }
        add(t, e) {
          "function" == typeof e && (this.element.addEventListener(t, e), this.events[t] = e)
        }
        remove(t) {
          this.element.removeEventListener(t, this.events[t]), delete this.events[t]
        }
      },
      n = class {
        constructor(t) {
          "string" == typeof t && (t = document.querySelector(t)), this.source = t, this.eventer = new s(this.source), this.style = Object.assign(new r(this.source), this.source.style)
        }
        get width() {
          return this.source.width
        }
        get height() {
          return this.source.height
        }
        set width(t) {
          this.source.width = t
        }
        set height(t) {
          this.source.height = t
        }
        get text() {
          return this.source.textContent
        }
        get html() {
          return this.source.innerHTML
        }
        set text(t) {
          this.source.textContent = t
        }
        set html(t) {
          this.source.innerHTML = t
        }
        get value() {
          return this.source.value
        }
        set value(t) {
          this.source.value = t
        }
        focus() {
          this.source.focus()
        }
        appendTo(t) {
          t.appendChild(this.source)
        }
      },
      o = class {
        constructor() {
          window.addEventListener("keydown", (t => {
            this[t.code] = !0
          })), window.addEventListener("keyup", (t => {
            this[t.code] = !1
          }))
        }
        hasKey(t) {
          return Boolean(this[t])
        }
        setKey(t, e) {
          this.hasKey(t) && (this[t] = e)
        }
        addKey(t, e) {
          this.hasKey(t) || (this[t] = e)
        }
        removeKey(t) {
          this.hasKey(t) && delete this[t]
        }
        toggleKey(t) {
          this.hasKey(t) && (this[t] = !this[t])
        }
        onKey(t, e) {
          this.hasKey(t) && !0 === (t = this[t]) && e(t)
        }
      },
      h = class {
        constructor() {
          this.isHandling = !1
        }
        rectBounds(t, e, i, r, s) {
          const n = {};
          return t.x <= e + t.width && (n.minX = !0), t.y <= i + t.height && (n.minY = !0), t.x >= r - t.width && (n.maxX = !0), t.y >= s - t.height && (n.maxY = !0), n
        }
      },
      a = class {
        constructor() {
          this.entities = {}
        }
        get list() {
          return Object.values(this.entities)
        }
        has(t) {
          return Boolean(this.entities[t])
        }
        getEntitiesByClassName(t) {
          return this.list.filter((e => t === e.constructor.name))
        }
        get(t) {
          return this.entities[t] ?? "not found"
        }
        add(...t) {
          Array.isArray(arguments[0]) && Array.isArray(t) && 1 === t.length && (t = t[0]);
          let e = t.length;
          for (; e--;) {
            const i = t[e];
            this.entities[i.id] = i
          }
        }
        remove(t) {
          this.has(t) && delete this.entities[t]
        }
        update() {
          let t = this.list.length;
          for (; t--;) this.list[t].update()
        }
      },
      c = class {
        constructor(t) {
          this.params = t, this.view = null, this.context = null, this.keyboard = new o, this.ticker = new e, this.managers = new class {
            constructor() {
              this.collisions = new h, this.entities = new a, this.GTCollisionsManager = h, this.GTEntitiesManager = a, this.list = {
                collisions: this.collision,
                entities: this.entities
              }
            }
            update() {
              this.entities.update()
            }
          }, this.config = null, this.scale = null, this.maxWidth = null, this.maxHeight = null
        }
        get width() {
          return this.view.width
        }
        get height() {
          return this.view.height
        }
        set width(t) {
          this.view.width = t
        }
        set height(t) {
          this.view.height = t
        }
        scaleResizer() {
          const {
            isNative: t,
            maxScreenWidth: e,
            maxScreenHeight: i
          } = this.params.fullScreen.resizer.scaleResizer, {
            innerWidth: r,
            innerHeight: s,
            devicePixelRatio: n
          } = window, o = t ? n : 1, h = r * o, a = s * o, c = Math.max(h / e, a / i) * o;
          this.scale = c, this.maxWidth = h / c, this.maxHeight = a / c, this.width = h, this.height = a, this.context.setScale(c, c)
        }
        resize(t) {
          const {
            fullScreen: e
          } = this.params;
          if (e.resizer) {
            const {
              beforeCallback: t
            } = e.resizer;
            "function" == typeof t && t()
          }
          const {
            scaleResizer: i
          } = e.resizer;
          i ? this.scaleResizer() : (this.width = window.innerWidth, this.height = window.innerHeight), "function" == typeof t && t()
        }
        create() {
          const e = document.createElement("canvas");
          if (this.params.id ? e.id = 0 !== this.params.id.toString().length ? this.params.id : "cvs_app" : e.id = "cvs_app", this.params.classes && this.params.classes.length) {
            const t = Object.values(this.params.classes);
            for (const i of t) e.classList.add(i)
          }
          this.view = new n(e), this.context = new t(this.view.source), this.input = new class {
            constructor(t) {
              this.element = t, this.mouse = {
                x: -100,
                y: -100,
                down: !1,
                up: !1,
                active: !1
              }
            }
            setMouseX(t) {
              this.mouse.x = t
            }
            setMouseY(t) {
              this.mouse.y = t
            }
            setMouseActive(t) {
              this.mouse.active = t
            }
            setMouseDown(t) {
              this.mouse.down = t
            }
            setMouseUp(t) {
              this.mouse.up = t
            }
            onMouseMove(t) {
              t.preventDefault(), t.stopPropagation(), this.setMouseX(t.clientX), this.setMouseY(t.clientY)
            }
            onMouseEnter() {
              this.setMouseActive(!0)
            }
            onMouseLeave() {
              this.setMouseActive(!1)
            }
            onMouseDown() {
              this.setMouseDown(!0), this.setMouseUp(!1)
            }
            onMouseUp() {
              this.setMouseUp(!0), this.setMouseDown(!1)
            }
            init() {
              return this.element.eventer.add("mousemove", this.onMouseMove.bind(this)), this.element.eventer.add("mouseenter", this.onMouseEnter.bind(this)), this.element.eventer.add("mouseleave", this.onMouseLeave.bind(this)), this.element.eventer.add("mousedown", this.onMouseDown.bind(this)), this.element.eventer.add("mouseup", this.onMouseUp.bind(this)), this
            }
          }(this.view).init()
        }
        appendTo(t) {
          if (this.create(), "string" == typeof t && (t = document.querySelector(t)), t.appendChild(this.view.source), this.params.fullScreen) {
            const {
              fullScreen: t
            } = this.params;
            if (t.resizer) {
              let {
                beforeCallback: e
              } = t.resizer;
              "function" == typeof e && e()
            }
            if (this.width = window.innerWidth, this.height = window.innerHeight, t.resizer) {
              let {
                parent: e = window,
                callback: i
              } = t.resizer;
              "function" == typeof i && i(), this.resize(i), e.addEventListener("resize", (() => {
                this.resize(i)
              }))
            }
          } else {
            const {
              width: t = 400,
              height: e = 400
            } = this.params;
            this.width = t, this.height = e
          }
        }
      },
      u = class {
        constructor() {
          this.PID2 = Math.PI / 2, this.PIM2 = 2 * Math.PI, this.radToDag = 180 / Math.PI, this.degToRad = Math.PI / 180
        }
        getDistance(t, e, i, r) {
          return Math.hypot(e - r, t - i)
        }
        getDirection(t, e, i, r) {
          return Math.atan2(e - r, t - i)
        }
        getAngleDistance(t, e) {
          const i = Math.abs(t - e) % this.PIM2;
          return i > Math.PI ? this.PIM2 - i : i
        }
        getRandom(t, e) {
          return void 0 === e && t > 0 && (e = t, t = 0), Math.floor(Math.random() * (e - t)) + t
        }
        canSee(t, e, i, r) {
          const s = Math.abs(e.position.x - t.position.x) - e.scale,
            n = Math.abs(e.position.y - t.position.y) - e.scale;
          return s <= i / 2 * 1.3 && n <= r / 2 * 1.3
        }
        getXYDir(t, e) {
          return {
            x: t * Math.cos(e),
            y: t * Math.sin(e)
          }
        }
        getXYVel(t, e, i, r) {
          const s = t.clone;
          s.velocity.add(i, r), s.updatePhysics();
          const n = this.getDirection(s.x, s.y, t.x, t.y);
          return Object.assign(this.getXYDir(e, n), {
            clone: s
          })
        }
        degreesToRadians(t) {
          return t * (Math.PI / 180)
        }
        lerp(t, e, i) {
          return t + (e - t) * i
        }
        decel(t, e) {
          return t > 0 ? Math.max(0, t - e) : t = Math.min(0, t + e)
        }
        isNumber(t) {
          return "number" == typeof t && !isNaN(t) && isFinite(t)
        }
        isString(t) {
          return t && "string" == typeof t
        }
        removeAllChildren(t) {
          for (; t.hasChildNodes();) t.removeChild(t.lastChild)
        }
        randomString(t) {
          const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
          let i = "";
          for (let r = 0; r < t; r++) i += e.charAt(Math.floor(Math.random() * e.length));
          return i
        }
        kFormat(t) {
          return t > 999 ? (t / 1e3).toFixed(1) + "k" : t
        }
        clog(t, e) {
          (/^\#[a-fA-F0-9]{6}$/.test(e) || /^rgb(a|)\((\d+(\,|)(\s|)){4}\)$/.test(e)) && (e = `color: ${e}`), console.log(`%c${t}`, e)
        }
        letterToUpperCase(t, e) {
          return t.split("").map(((t, i) => i === e ? t.toUpperCase() : t)).join("")
        }
        async sleep(t) {
          return new Promise((e => {
            setTimeout((() => {
              e()
            }), t)
          }))
        }
      };
    class f {
      constructor(t = 0, e = 0) {
        this.x = t, this.y = e
      }
      static random2D(t, e = 1) {
        return new Vector(e * Math.cos(t), e * Math.sin(t))
      }
      get magnitude() {
        return Math.sqrt(this.x ** 2 + this.y ** 2)
      }
      setMag(t) {
        return this.normalize().mult(t)
      }
      set(t, e) {
        return this.x = t, this.y = e, this
      }
      add(t, e) {
        const i = new f(t, e);
        return this.x += i.x, this.y += i.y, this
      }
      sub(t) {
        return this.x -= t.x, this.y -= t.y, this
      }
      mult(t) {
        return this.x *= t, this.y *= t, this
      }
      div(t) {
        return this.x /= t, this.y /= t, this
      }
      mulScalar(t) {
        return this.x * t.x + this.y * t.y
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
      }
      normalize() {
        const t = this.magnitude;
        return t > 0 && this.div(t), this
      }
      projection(t) {
        const e = t.normalize(),
          i = this.mulScalar(t);
        return e.mult(i), e
      }
      reset() {
        return this.x = 0, this.y = 0, this
      }
    }
    var l = f,
      d = class {
        constructor(t, e, i = 5, r = .9) {
          this.mass = i, this.time = r, this.position = new l(t, e), this.velocity = new l, this.acceleration = new l, this.force = new l
        }
        updatePhysics() {
          this.force.div(this.mass), this.acceleration.add(this.force.x, this.force.y), this.acceleration.mult(this.time), this.velocity.add(this.acceleration.x, this.acceleration.y), this.velocity.mult(this.time), this.position.add(this.velocity.x, this.velocity.y)
        }
        resetPhysics() {
          this.force.reset(), this.acceleration.reset(), this.velocity.reset()
        }
      };
    class p extends d {
      constructor(t, e, i, r) {
        super(t, e), this.width = i, this.height = r
      }
      get x() {
        return this.position.x - this.width / 2
      }
      get y() {
        return this.position.y - this.height / 2
      }
      set x(t) {
        this.position.set(t + this.width / 2, this.position.y)
      }
      set y(t) {
        this.position.set(this.position.x, t + this.height / 2)
      }
      get clone() {
        return new p(this.position.x, this.position.y, this.width, this.height)
      }
      setTo(t, e) {
        this.position.set(t + this.width / 2, e + this.height / 2)
      }
      copyFrom(t) {
        this.setTo(t.position.x, t.position.y)
      }
      copyTo(t) {
        t.setTo(t.position.x, t.position.y)
      }
    }
    var y = p,
      v = class {
        constructor(t) {
          for (const e in t) {
            const i = t[e];
            this[e] = i
          }
        }
        get(t) {
          if (this.has(t)) return this[t]
        }
        has(t) {
          return Boolean(this[t])
        }
        isValue(t, e) {
          if (this.has(t)) return this.get(t) === e
        }
        add(t, e) {
          this.has(t) || (this[t] = e)
        }
        get(t) {
          return this[t]
        }
        set(t, e) {
          this.has(t) && (this[t] = e)
        }
        remove(t) {
          this.has(t) && delete this[t]
        }
      };
    const g = new u;
    var w = class extends d {
      constructor(t, e, i, d) {
        if (super(0, 0), !t) throw new Error("The camera can't work without a clear map size");
        this.mapScale = t, this.maxDistance = e || 50, this.isStatic = d, this.speed = i || .01, this.mapScaleMiddle = this.mapScale / 2, this.xVel = 0, this.yVel = 0, this.target = null
      }
      get x() {
        return this.position.x
      }
      get y() {
        return this.position.y
      }
      set x(t) {
        this.position = new l(t, this.y)
      }
      set y(t) {
        this.position = new l(this.x, t)
      }
      update(t, e) {
        if (this.target = t, this.target) {
          const t = g.getDistance(this.x, this.y, this.target.x, this.target.y),
            i = g.getDirection(this.target.x, this.target.y, this.x, this.y),
            r = Math.min(t * this.speed * e, t);
          t > this.maxDistance && !this.isStatic ? (this.xVel = r * Math.cos(i), this.yVel = r * Math.sin(i), this.position.add(this.xVel, this.yVel)) : (this.x = this.target.x, this.y = this.target.y)
        } else this.position = new l(this.mapScaleMiddle, this.mapScaleMiddle);
        this.updatePhysics()
      }
    };
    const m = new u;
    var x = class {
      constructor() {
        this.angle = 0, this.x = 0, this.y = 0, this.scale = 0, this.joystickX = 0, this.joystickY = 0, this.mouseX = 0, this.mouseY = 0, this.canvas = null, this.context = null, this.ticker = new e
      }
      show(t) {
        this.x = t.clientX - this.scale / 2, this.y = t.clientY - this.scale / 2, this.ticker.start(), this.canvas.style.set("display", "block"), this.canvas.style.set({
          top: `${this.y}px`,
          left: `${this.x}px`
        })
      }
      hide() {
        this.ticker.stop(), this.canvas.style.set("display", "none"), this.joystickX = this.scale / 2, this.joystickY = this.scale / 2, this.mouseX = this.scale / 2, this.mouseY = this.scale / 2
      }
      render() {
        const t = this.scale / 2,
          e = this.scale / 3,
          i = e / 2;
        this.context.begin(t, t).setColors("#d0d0d0", "#d0d0d0").setLineWidth(4).setAlpha(.4).circle(e).setAlpha(1).circle(e, "stroke").end(), this.context.begin(this.joystickX, this.joystickY).setColors("#d0d0d0", "#d0d0d0").setLineWidth(4).setAlpha(.4).circle(i).setAlpha(1).circle(i, "stroke").end()
      }
      mouseMove(t) {
        this.mouseX = t.layerX, this.mouseY = t.layerY
      }
      update() {
        this.context.clear();
        const t = this.scale / 2,
          e = this.scale / 3,
          i = m.getDistance(t, t, this.joystickX, this.joystickY),
          r = m.getDistance(this.mouseX, this.mouseY, this.joystickX, this.joystickY),
          s = m.getDirection(this.mouseX, this.mouseY, this.joystickX, this.joystickY),
          n = Math.min(i, r);
        i < e && (this.angle = s, this.joystickX = n * Math.cos(this.angle), this.joystickY = n * Math.sin(this.angle)), this.render()
      }
      init({
        node: e,
        scale: i
      }) {
        const r = new n(document.createElement("canvas"));
        r.appendTo(e), r.source.id = "joystick_app", r.style.set({
          position: "absolute",
          width: `${i}px`,
          height: `${i}px`
        }), r.source.width = r.source.height = i, this.ticker.add(this.update.bind(this)), this.canvas = r, this.context = new t(this.canvas.source), this.scale = i, this.hide(), window.addEventListener("mousedown", this.show.bind(this)), window.addEventListener("mouseup", this.hide.bind(this)), this.canvas.eventer.add("mousemove", this.mouseMove.bind(this))
      }
    },
      b = class {
        constructor({
          id: t,
          x: e,
          y: i,
          width: r,
          height: s,
          contextStyles: n,
          textSize: o,
          textFontName: h,
          textBold: a,
          cursorColor: c
        }) {
          this.id = t, this.x = e, this.y = i, this.width = r, this.height = s, this.contextStyles = n, this.textSize = o ?? 16, this.textFontName = h ?? "", this.textBold = a ?? !1, this.cursorColor = c ?? "#000000", this.context = null, this.isHovered = !1, this.cursorBlikingTime = Date.now(), this.cursorBlikingCooldown = 500, this.cursorAlpha = 0, this.cursorMaxAlpha = 1, this.cursorWidth = 1, this.cursorHeight = this.textSize, this.paddingX = 5, this.printX = this.x + this.paddingX, this.printY = this.middleY - this.textSize / 2, this.minPrintX = this.printX, this.value = "", this.lastInputKey = "", window.addEventListener("keydown", this.onKeyDown.bind(this))
        }
        get middleX() {
          return this.x + this.width / 2
        }
        get middleY() {
          return this.y + this.height / 2
        }
        clearRender() {
          if (this.contextStyles) {
            const {
              lineWidth: t
            } = this.contextStyles, e = t, i = t;
            return this.context.source.clearRect(this.x - e, this.y - i, this.width + 2 * e, this.height + 2 * i)
          }
          this.context.source.clearRect(this.x, this.y, this.width, this.height)
        }
        onKeyDown(t) {
          if ("Backspace" === t.key && this.value.length > 0) {
            const t = this.value.split(""),
              e = t[t.length - 1],
              i = this.context.getTextWidth(e);
            return t.pop(), this.value = t.join(""), this.updatePrintPosition("left", i)
          }
          if (t.key.length > 1) return;
          if (" " === this.lastInputKey && this.lastInputKey === t.key) return;
          this.value += t.key, this.lastInputKey = t.key;
          const e = this.context.getTextWidth(t.key);
          this.updatePrintPosition("right", e)
        }
        updatePrintPosition(t, e) {
          console.log(e), e *= 2, "left" !== t || this.printX === this.minPrintX ? this.printX += e : this.printX -= e
        }
        renderCursor() {
          this.context.begin(this.printX, this.printY).setAlpha(this.cursorAlpha).rect(this.cursorWidth, this.cursorHeight).end()
        }
        updateCursor() {
          Date.now() - this.cursorBlikingTime >= this.cursorBlikingCooldown && (this.cursorBlikingTime = Date.now()), this.cursorAlpha = this.cursorMaxAlpha - (Date.now() - this.cursorBlikingTime) / this.cursorBlikingCooldown, this.renderCursor()
        }
        renderText() {
          const t = this.context.getTextHeight(this.value);
          this.context.begin(this.x + this.paddingX, this.middleY + t / 2 + 1).setAlign("left").setFont(`${this.textBold ? "bold" : ""} ${this.textSize}px ${this.textFontName}`).text(this.value).end()
        }
        render() {
          if (this.contextStyles) {
            const {
              fillColor: t,
              strokeColor: e,
              lineWidth: i,
              borderRadius: r
            } = this.contextStyles;
            this.context.begin(this.x, this.y), (t || e) && this.context.setColors(t, e), i && this.context.setLineWidth(i);
            const s = r ? "roundRect" : "rect";
            return this.context[s](this.width, this.height, "roundRect" === s ? r : "fill", "fill"), e && this.context[s](this.width, this.height, "roundRect" === s ? r : "stroke", "stroke"), this.context.end()
          }
          this.context.begin(this.x, this.y).setColors("#ffffff", "#000000").setLineWidth(2).rect(this.width, this.height).rect(this.width, this.height, "stroke").end()
        }
        update({
          mouseX: t,
          mouseY: e,
          context: i
        }) {
          this.context = i, this.context && (this.render(), this.renderText(), this.updateCursor())
        }
      },
      k = class {
        constructor(t) {
          if (!t) throw new Error("Specify the parameters for the GTGui constructor");
          t.id = t.id ?? "gui_app", this.canvas = new c(t), this.canvas.appendTo(document.body), this.canvas.view.style.set("position", "absolute"), this.canvas.view.style.set("top", "0"), this.canvas.view.style.set("pointer-events", "none"), this.canvas.view.style.set("z-index", "999999999"), this.guiObjects = {}, this.Input = b
        }
        get list() {
          return Object.values(this.guiObjects)
        }
        has(t) {
          return Boolean(this.guiObjects[t])
        }
        get(t) {
          return this.guiObjects[t] ?? "not found"
        }
        add(...t) {
          Array.isArray(arguments[0]) && Array.isArray(t) && 1 === t.length && (t = t[0]);
          let e = t.length;
          for (; e--;) {
            const i = t[e];
            this.guiObjects[i.id] = i
          }
        }
        remove(t) {
          this.has(t) && delete this.guiObjects[t]
        }
        update({
          mouse: t
        }) {
          this.canvas.input.mouse.x = t.x, this.canvas.input.mouse.y = t.y, this.canvas.input.mouse.down = t.down, this.canvas.context.clear();
          let e = this.list.length;
          for (; e--;) this.list[e].update({
            mouseX: this.canvas.input.mouse.x,
            mouseY: this.canvas.input.mouse.y,
            context: this.canvas.context
          })
        }
      },
      E = i(374),
      A = class {
        constructor({
          url: t,
          packetType: e = "json",
          hideMsgpack: i = !1
        }) {
          this.url = t, this.packetType = e, this.hideMsgpack = i, this.websocket = null, this.events = {}, this.hideMsgpack || (this.msgpack = E), delete this.hideMsgpack
        }
        get isReady() {
          return this.isCreated && 1 === this.websocket?.readyState
        }
        get isCreated() {
          return null !== this.websocket
        }
        send(t) {
          this.isReady && (t = this.encodePacket(t), this.websocket.send(t))
        }
        encodePacket(t) {
          return "msgpack" === this.packetType ? E.encode(t) : JSON.stringify(t)
        }
        decodePacket(t) {
          return "msgpack" === this.packetType ? (t = new Uint8Array(t), t = E.decode(t)) : t = JSON.parse(t), t
        }
        on(t, e, i, r = {}) {
          if (this.isCreated) {
            if (!t) throw new Error('[Bad Argument] Custom key (customKey) is a required argument. It helps to find this event in the "events" object');
            this.websocket.addEventListener(e, i, r), this.events[t] = {
              customKey: t,
              event: e,
              callback: i,
              options: r
            }
          }
        }
        removeEvent(t) {
          const e = this.events[t];
          this.websocket.removeEventListener(e.event, e.callback, e.options), delete this.events[t]
        }
        connect(t) {
          this.isCreated || (this.websocket = new WebSocket(this.url), "msgpack" === this.packetType && (this.websocket.binaryType = "arraybuffer"), t())
        }
      },
      U = class {
        constructor() {
          this.GTCanvas = c, this.GTContext = t, this.GTTicker = e, this.GTElement = n, this.GTStyle = r, this.GTEventer = s, this.GTKeyboard = o, this.GTVector = l, this.GTPhysics = d, this.GTPoint = y, this.GTConfig = v, this.GTCamera = w, this.GTJoystick = x, this.GTGui = k, this.GTSocket = A, this.utils = new u, this.gtUtils = this.utils
        }
      };
    window.GameTool = new U, window.gt = new U
  }()
}();
